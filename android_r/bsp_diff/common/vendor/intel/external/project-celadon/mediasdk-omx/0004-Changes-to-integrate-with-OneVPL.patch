From fd14b20328af896152d084954d97893f21e295d8 Mon Sep 17 00:00:00 2001
From: neeraj solanki <neeraj.solanki@intel.com>
Date: Thu, 24 Feb 2022 22:50:41 +0530
Subject: [PATCH] Changes to integrate with OneVPL

- Updated required libraries and headers for OneVPL integration.
- Modified HW Encoder/Decoder component initialization and session
creation for OneVPL.
- Resolved errors related to MFX VPL implementation loading for HW
Encoder/Decoder components.

Change-Id: I65984907bfa5658230ebb42846dc0651fba31aa4
Tracked-On: OAM-100436
Signed-off-by: Neeraj Solanki <neeraj.solanki@intel.com>
---
 mfx_omx_defs.mk                               |  19 +-
 omx_components/Android.mk                     |   5 +
 .../include/mfx_omx_vdec_component.h          |   6 +
 .../include/mfx_omx_venc_component.h          |   5 +
 omx_components/include/mfx_omx_vpp_wrapp.h    |   8 +
 omx_components/src/mfx_omx_vdec_component.cpp | 247 ++++++++++++++++++
 omx_components/src/mfx_omx_venc_component.cpp | 121 ++++++++-
 omx_components/src/mfx_omx_vpp_wrapp.cpp      |  22 +-
 omx_utils/include/mfx_omx_defs.h              |   8 +
 omx_utils/include/mfx_omx_dev.h               |   4 +
 omx_utils/include/mfx_omx_dev_android.h       |   4 +
 omx_utils/src/mfx_omx_debug.cpp               |   4 +
 omx_utils/src/mfx_omx_dev_android.cpp         |  30 +++
 13 files changed, 477 insertions(+), 6 deletions(-)

diff --git a/mfx_omx_defs.mk b/mfx_omx_defs.mk
index 1a6ae03..a41278d 100644
--- a/mfx_omx_defs.mk
+++ b/mfx_omx_defs.mk
@@ -54,6 +54,12 @@ ifneq ($(filter MFX_O MFX_O_MR1, $(MFX_ANDROID_VERSION)),)
   MFX_OMX_CFLAGS += -DMFX_VERSION=1026
 endif
 
+# Use oneVPL API
+ifeq ($(USE_ONEVPL),true)
+  MFX_OMX_CFLAGS += -DMFX_VERSION=2006
+  MFX_OMX_CFLAGS += -DUSE_ONEVPL
+endif
+
 # Passing Android-dependency information to the code
 MFX_OMX_CFLAGS += \
   -DMFX_ANDROID_VERSION=$(MFX_ANDROID_VERSION) \
@@ -77,7 +83,7 @@ MFX_OMX_CFLAGS += \
   -DMFX_PRODUCT_VERSION=\"$(MFX_VERSION)\"
 
 # Treat all warnings as error
-MFX_OMX_CFLAGS += -Wall -Werror -Wno-tautological-compare
+MFX_OMX_CFLAGS += -Wall -Werror -Wno-tautological-compare -Wno-deprecated-declarations
 
 #  Security
 MFX_OMX_CFLAGS += \
@@ -109,8 +115,15 @@ endif
 
 MFX_OMX_INCLUDES_LIBVA := $(TARGET_OUT_HEADERS)/libva
 
-# Setting MediaSDK imported headers
-MFX_OMX_HEADER_LIBRARIES := libmfx_headers
+ifeq ($(USE_ONEVPL), true)
+  # Setting oneVPL imported headers
+  MFX_OMX_HEADER_LIBRARIES := libvpl_headers libmfx_android_headers
+  MFX_OMX_SHARED_LIBS := libvpl
+else
+  # Setting MediaSDK imported headers
+  MFX_OMX_HEADER_LIBRARIES := libmfx_headers
+endif
+
 
 # Setting usual imported headers
 ifneq ($(filter MFX_O_MR1 MFX_P MFX_Q MFX_R MFX_S,$(MFX_ANDROID_VERSION)),)
diff --git a/omx_components/Android.mk b/omx_components/Android.mk
index a3f6864..e518c77 100644
--- a/omx_components/Android.mk
+++ b/omx_components/Android.mk
@@ -29,8 +29,13 @@ LOCAL_SHARED_LIBRARIES := \
     libui \
     libutils
 
+ifeq ($(USE_ONEVPL), true)
+  LOCAL_SHARED_LIBRARIES += \
+    libvpl
+else
 LOCAL_SHARED_LIBRARIES_32 := libmfxhw32
 LOCAL_SHARED_LIBRARIES_64 := libmfxhw64
+endif
 
 LOCAL_STATIC_LIBRARIES := libmfx_omx_buffers libmfx_omx_utils
 LOCAL_HEADER_LIBRARIES := $(MFX_OMX_HEADER_LIBRARIES)
diff --git a/omx_components/include/mfx_omx_vdec_component.h b/omx_components/include/mfx_omx_vdec_component.h
index 43c6051..3069bc4 100644
--- a/omx_components/include/mfx_omx_vdec_component.h
+++ b/omx_components/include/mfx_omx_vdec_component.h
@@ -163,7 +163,13 @@ protected:
 
 protected:
     mfxIMPL m_Implementation;
+#ifdef USE_ONEVPL
+    mfxSession m_Session;
+    mfxLoader m_Loader;
+#else
     MFXVideoSession m_Session;
+#endif
+
     MFXVideoDECODE* m_pDEC;
     MfxOmxMutex m_decoderMutex;
     mfxVideoParam m_MfxVideoParams;
diff --git a/omx_components/include/mfx_omx_venc_component.h b/omx_components/include/mfx_omx_venc_component.h
index 3bb68ac..efd5d42 100644
--- a/omx_components/include/mfx_omx_venc_component.h
+++ b/omx_components/include/mfx_omx_venc_component.h
@@ -161,7 +161,12 @@ protected:
     void SkipFrame(void);
 protected:
     mfxIMPL m_Implementation;
+#ifdef USE_ONEVPL
+    mfxSession m_Session;
+    mfxLoader m_Loader;
+#else
     MFXVideoSession m_Session;
+#endif
     MFXVideoENCODE* m_pENC;
     MfxOmxMutex m_encoderMutex;
 
diff --git a/omx_components/include/mfx_omx_vpp_wrapp.h b/omx_components/include/mfx_omx_vpp_wrapp.h
index a51238b..75a42c2 100644
--- a/omx_components/include/mfx_omx_vpp_wrapp.h
+++ b/omx_components/include/mfx_omx_vpp_wrapp.h
@@ -45,7 +45,11 @@ enum MfxOmxConversion
 
 struct MfxOmxVppWrappParam
 {
+#ifdef USE_ONEVPL
+    mfxSession         session;
+#else
     MFXVideoSession   *session;
+#endif
     mfxFrameInfo      *frame_info;
     mfxFrameAllocator *allocator;
 
@@ -72,7 +76,11 @@ protected:
     mfxStatus DumpSurface(mfxFrameSurface1 *surface, FILE *file);
 
     MFXVideoVPP *m_pVPP;
+#ifdef USE_ONEVPL
+    mfxSession m_Session;
+#else
     MFXVideoSession *m_session;
+#endif
     mfxVideoParam m_vppParam;
     mfxFrameAllocator m_allocator;
 
diff --git a/omx_components/src/mfx_omx_vdec_component.cpp b/omx_components/src/mfx_omx_vdec_component.cpp
index e4872eb..7d86c32 100644
--- a/omx_components/src/mfx_omx_vdec_component.cpp
+++ b/omx_components/src/mfx_omx_vdec_component.cpp
@@ -70,6 +70,10 @@ MfxOmxVdecComponent::MfxOmxVdecComponent(OMX_ERRORTYPE &error,
                                          OMX_U32 flags):
     MfxOmxComponent(error, self, reg_data, flags),
     m_Implementation(MFX_OMX_IMPLEMENTATION),
+#ifdef USE_ONEVPL
+    m_Session(nullptr),
+    m_Loader(nullptr),
+#endif
     m_pDEC(NULL),
     m_extBuffers{},
     m_bLegacyAdaptivePlayback(false),
@@ -129,7 +133,11 @@ MfxOmxVdecComponent::~MfxOmxVdecComponent(void)
     MFX_OMX_DELETE(m_pOmxBitstream);
     MFX_OMX_DELETE(m_pSurfaces);
     MFX_OMX_DELETE(m_pDEC);
+#ifdef USE_ONEVPL
+    MFXClose(m_Session);
+#else
     m_Session.Close();
+#endif
 
     MFX_OMX_DELETE(m_pDevice);
 
@@ -137,12 +145,237 @@ MfxOmxVdecComponent::~MfxOmxVdecComponent(void)
     if (m_dbg_decin_fc) fclose(m_dbg_decin_fc);
     if (m_dbg_decout) fclose(m_dbg_decout);
 
+#ifdef USE_ONEVPL
+    if (m_Loader) {
+        MFXUnload(m_Loader);
+        m_Loader = nullptr;
+    }
+#endif
+
     MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "Decoded %d frames", m_nCountDecodedFrames);
     MFX_OMX_LOG_INFO("Destroyed %s", m_pRegData->m_name);
 }
 
 /*------------------------------------------------------------------------------*/
 
+#ifdef USE_ONEVPL
+OMX_ERRORTYPE MfxOmxVdecComponent::Init(void)
+{
+    MFX_OMX_AUTO_TRACE_FUNC();
+    OMX_ERRORTYPE error = MfxOmxComponent::Init();
+    mfxStatus sts = MFX_ERR_NONE;
+
+    if (OMX_ErrorNone == error)
+    {
+        Reset();
+
+        mfxConfig cfg[2];
+        mfxVariant cfgVal[2];
+
+        m_Loader = MFXLoad();
+        if (nullptr == m_Loader) {
+            ALOGE("MFXLoad failed...is implementation in path?");
+            return OMX_ErrorUndefined;
+        }
+
+        /* Create configurations for implementation */
+        cfg[0] = MFXCreateConfig(m_Loader);
+        if (!cfg[0]) {
+            ALOGE("Failed to create a MFX configuration");
+            MFXUnload(m_Loader);
+            return OMX_ErrorUndefined;
+        }
+
+        cfgVal[0].Type = MFX_VARIANT_TYPE_U32;
+        cfgVal[0].Data.U32 = (m_Implementation == MFX_IMPL_SOFTWARE) ? MFX_IMPL_TYPE_SOFTWARE : MFX_IMPL_TYPE_HARDWARE;
+        sts = MFXSetConfigFilterProperty(cfg[0], (const mfxU8 *) "mfxImplDescription.Impl", cfgVal[0]);
+        if (MFX_ERR_NONE != sts) {
+            ALOGE("Failed to add an additional MFX configuration (%d)", sts);
+            MFXUnload(m_Loader);
+            return OMX_ErrorUndefined;
+        }
+
+        cfg[1] = MFXCreateConfig(m_Loader);
+        if (!cfg[1]) {
+            ALOGE("Failed to create a MFX configuration");
+            MFXUnload(m_Loader);
+            return OMX_ErrorUndefined;
+        }
+
+        cfgVal[1].Type = MFX_VARIANT_TYPE_U32;
+        cfgVal[1].Data.U32 = MFX_VERSION;
+        sts = MFXSetConfigFilterProperty(cfg[1], (const mfxU8 *) "mfxImplDescription.ApiVersion.Version", cfgVal[1]);
+        if (MFX_ERR_NONE != sts) {
+            ALOGE("Failed to add an additional MFX configuration (%d)", sts);
+            MFXUnload(m_Loader);
+            return OMX_ErrorUndefined;
+        }
+
+        while (1) {
+            /* Enumerate all implementations */
+            uint32_t idx = 0;
+            mfxImplDescription *idesc;
+            sts = MFXEnumImplementations(m_Loader, idx, MFX_IMPLCAPS_IMPLDESCSTRUCTURE, (mfxHDL *)&idesc);
+
+            if (MFX_ERR_NOT_FOUND == sts) {
+                /* Failed to find an available implementation */
+                break;
+            }
+            else if (MFX_ERR_NONE != sts) {
+                /*implementation found, but requested query format is not supported*/
+                idx++;
+                continue;
+            }
+            ALOGI("OneVPL %s. Idx = %d. ApiVersion: %d.%d. Implementation type: %s. AccelerationMode via: %d",
+                 __func__, idx, idesc->ApiVersion.Major, idesc->ApiVersion.Minor,
+                (idesc->Impl == MFX_IMPL_TYPE_SOFTWARE) ? "SW" : "HW",
+                idesc->AccelerationMode);
+
+            sts = MFXCreateSession(m_Loader, idx, &m_Session);
+
+            MFXDispReleaseImplDescription(m_Loader, idesc);
+
+            if (MFX_ERR_NONE == sts)
+                break;
+
+            idx++;
+        }
+
+        if (MFX_ERR_NONE != sts)
+        {
+            if (m_Loader)
+                MFXUnload(m_Loader);
+
+            ALOGE("Failed to create a MFX session (%d)", sts);
+            return OMX_ErrorUndefined;
+        }
+
+        // decoder creation
+        if (MFX_ERR_NONE == sts)
+        {
+            MFX_OMX_NEW(m_pDEC, MFXVideoDECODE(m_Session));
+            if (!m_pDEC) sts = MFX_ERR_MEMORY_ALLOC;
+        }
+        if (MFX_ERR_NONE != sts) error = ErrorStatusMfxToOmx(sts);
+    }
+
+    if ((OMX_ErrorNone == error) && (MFX_IMPL_SOFTWARE != m_Implementation))
+    {
+        // driver initialization
+        m_pDevice = mfx_omx_create_dev();
+        if (m_pDevice) sts = m_pDevice->DevInit();
+        else sts = MFX_ERR_DEVICE_FAILED;
+
+        if (MFX_ERR_NONE != sts)
+        {
+            MFX_OMX_DELETE(m_pDevice);
+            error = OMX_ErrorHardware;
+        }
+        MFX_OMX_AUTO_TRACE_P(m_pDevice);
+    }
+
+    if ((OMX_ErrorNone == error) && (MFX_IMPL_SOFTWARE != m_Implementation))
+    {
+        sts = m_pDevice->InitMfxSession(m_Session);
+        if (MFX_ERR_NONE != sts) error = ErrorStatusMfxToOmx(sts);
+    }
+
+
+    if (OMX_ErrorNone == error)
+    {
+        MfxOmxFrameConstructorType fc_type;
+        switch (m_pRegData->m_type)
+        {
+        case MfxOmx_h264vd:
+            fc_type = MfxOmxFC_AVC;
+            break;
+        case MfxOmx_h265vd:
+            fc_type = MfxOmxFC_HEVC;
+            break;
+        case MfxOmx_vc1vd:
+            fc_type = MfxOmxFC_VC1;
+            break;
+        case MfxOmx_vp8vd:
+            fc_type = MfxOmxFC_VP8;
+            break;
+        case MfxOmx_vp9vd:
+            fc_type = MfxOmxFC_VP9;
+            break;
+        default:
+            fc_type = MfxOmxFC_None;
+            break;
+        }
+        if (MFX_ERR_NONE == sts)
+        {
+            MFX_OMX_NEW(m_pOmxBitstream, MfxOmxBitstream(fc_type, sts));
+        }
+
+        if (MFX_ERR_NONE == sts)
+        {
+            if (m_pOmxBitstream)
+            {
+#if MFX_OMX_DEBUG_DUMP == MFX_OMX_YES
+                if (MFX_OMX_COMPONENT_FLAGS_DUMP_INPUT & m_Flags)
+                {
+                    m_dbg_decin = fopen(MFX_OMX_DECIN_FILE, "w");
+                    m_dbg_decin_fc = fopen(MFX_OMX_DECIN_FC_FILE, "w");
+                }
+#endif
+                m_pOmxBitstream->GetFrameConstructor()->SetFiles(m_dbg_decin, m_dbg_decin_fc);
+            }
+            else sts = MFX_ERR_NULL_PTR;
+        }
+        if (MFX_ERR_NONE == sts)
+        {
+            sts = m_pOmxBitstream->SetBuffersCallback(this);
+        }
+        if (MFX_ERR_NONE != sts)
+        {
+            if (MFX_ERR_UNSUPPORTED == sts) error = OMX_ErrorComponentNotFound;
+            else error = ErrorStatusMfxToOmx(sts);
+        }
+    }
+    if (OMX_ErrorNone == error)
+    {
+        MFX_OMX_NEW(m_pSurfaces, MfxOmxSurfacesPool(m_MfxVideoParams.mfx.CodecId, sts));
+        if ((MFX_ERR_NONE == sts) && !m_pSurfaces)
+        {
+            sts = MFX_ERR_NULL_PTR;
+        }
+#if MFX_OMX_DEBUG_DUMP == MFX_OMX_YES
+        if (MFX_ERR_NONE == sts)
+        {
+            if (MFX_OMX_COMPONENT_FLAGS_DUMP_OUTPUT & m_Flags)
+            {
+                m_dbg_decout = fopen(MFX_OMX_DECOUT_FILE, "w");
+            }
+            m_pSurfaces->SetFile(m_dbg_decout);
+        }
+#endif
+        if (MFX_ERR_NONE == sts)
+        {
+            sts = m_pSurfaces->SetBuffersCallback(this);
+        }
+        if ((MFX_ERR_NONE == sts) && (MFX_IMPL_SOFTWARE != m_Implementation))
+        {
+            m_pSurfaces->SetMfxDevice(m_pDevice);
+        }
+        if (MFX_ERR_NONE != sts) error = ErrorStatusMfxToOmx(sts);
+    }
+
+    if (OMX_ErrorNone == error)
+    {
+        MFX_OMX_LOG_INFO("Created %s", m_pRegData->m_name);
+    }
+    else
+    {
+        MFX_OMX_LOG_ERROR("Failed to create %s, error 0x%x", m_pRegData->m_name, error);
+    }
+    MFX_OMX_AUTO_TRACE_I32(sts);
+
+    return error;
+}
+#else
 OMX_ERRORTYPE MfxOmxVdecComponent::Init(void)
 {
     MFX_OMX_AUTO_TRACE_FUNC();
@@ -156,6 +389,7 @@ OMX_ERRORTYPE MfxOmxVdecComponent::Init(void)
         // prepare Media SDK
         sts = m_Session.Init(m_Implementation, &g_MfxVersion);
         MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "Session.Init sts %d, version %d.%d", sts, g_MfxVersion.Major, g_MfxVersion.Minor);
+        ALOGI("Session.Init sts %d, version %d.%d", sts, g_MfxVersion.Major, g_MfxVersion.Minor);
 
         if (MFX_ERR_NONE == sts)
         {
@@ -284,6 +518,7 @@ OMX_ERRORTYPE MfxOmxVdecComponent::Init(void)
 
     return error;
 }
+#endif
 
 /*------------------------------------------------------------------------------*/
 
@@ -2156,6 +2391,9 @@ mfxU16 MfxOmxVdecComponent::GetAsyncDepth(void)
     MFX_OMX_AUTO_TRACE_FUNC();
 
     mfxU16 asyncDepth;
+#ifdef USE_ONEVPL
+    asyncDepth = (MFX_IMPL_BASETYPE(m_Implementation) == MFX_IMPL_SOFTWARE) ? 0 : 1;
+#else
     if ((MFX_IMPL_HARDWARE == MFX_IMPL_BASETYPE(m_Implementation)) &&
         ((MFX_CODEC_AVC == m_MfxVideoParams.mfx.CodecId) ||
          (MFX_CODEC_HEVC == m_MfxVideoParams.mfx.CodecId) ||
@@ -2164,6 +2402,7 @@ mfxU16 MfxOmxVdecComponent::GetAsyncDepth(void)
         asyncDepth = 1;
     else
         asyncDepth = 0;
+#endif
 
     MFX_OMX_AUTO_TRACE_I32(asyncDepth);
     return asyncDepth;
@@ -2989,7 +3228,11 @@ mfxStatus MfxOmxVdecComponent::DecodeFrame(void)
                 mfxSyncPoint* pDevBusySyncPoint = m_pSurfaces->GetSyncPoint();
                 if (pDevBusySyncPoint)
                 {
+#ifdef USE_ONEVPL
+                    mfx_sts = MFXVideoCORE_SyncOperation(m_Session, *pDevBusySyncPoint, MFX_OMX_INFINITE);
+#else
                     mfx_sts = m_Session.SyncOperation(*pDevBusySyncPoint, MFX_OMX_INFINITE);
+#endif
                 }
                 else
                 {
@@ -3116,7 +3359,11 @@ void MfxOmxVdecComponent::AsyncThread(void)
                 {
                     MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "SyncOperation+");
                     MFX_OMX_AUTO_TRACE("SyncOperation");
+#ifdef USE_ONEVPL
+                    mfx_res = MFXVideoCORE_SyncOperation(m_Session, *pSyncPoint, MFX_OMX_INFINITE);
+#else
                     mfx_res = m_Session.SyncOperation(*pSyncPoint, MFX_OMX_INFINITE);
+#endif
                     MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "SyncOperation-");
                     m_pDevBusyEvent->Signal();
                 }
diff --git a/omx_components/src/mfx_omx_venc_component.cpp b/omx_components/src/mfx_omx_venc_component.cpp
index 2df1c30..d915c16 100755
--- a/omx_components/src/mfx_omx_venc_component.cpp
+++ b/omx_components/src/mfx_omx_venc_component.cpp
@@ -69,6 +69,10 @@ MfxOmxVencComponent::MfxOmxVencComponent(OMX_ERRORTYPE &error,
                                          OMX_U32 flags):
     MfxOmxComponent(error, self, reg_data, flags),
     m_Implementation(MFX_OMX_IMPLEMENTATION),
+#ifdef USE_ONEVPL
+    m_Session(nullptr),
+    m_Loader(nullptr),
+#endif
     m_pENC(NULL),
     m_MfxVideoParams(m_OmxMfxVideoParams),
     m_MfxEncodeCtrl(m_OmxMfxEncodeCtrl),
@@ -118,12 +122,24 @@ MfxOmxVencComponent::~MfxOmxVencComponent(void)
     MFX_OMX_DELETE(m_pSurfaces);
     MFX_OMX_DELETE(m_pENC);
     m_VPP.Close();
+#ifdef USE_ONEVPL
+    MFXClose(m_Session);
+#else
     m_Session.Close();
+#endif
 
     MFX_OMX_DELETE(m_pDevice);
 
     if (m_dbg_encin) fclose(m_dbg_encin);
     if (m_dbg_encout) fclose(m_dbg_encout);
+
+#ifdef USE_ONEVPL
+    if (m_Loader) {
+        MFXUnload(m_Loader);
+        m_Loader = nullptr;
+    }
+#endif
+
     MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "Encoded %d frames", m_nEncoderOutputBitstreamsCount);
     MFX_OMX_LOG_INFO("Destroyed %s", m_pRegData->m_name);
 }
@@ -141,15 +157,98 @@ OMX_ERRORTYPE MfxOmxVencComponent::Init(void)
         Reset();
 
         // prepare Media SDK
+#ifdef USE_ONEVPL
+        mfxConfig cfg[2];
+        mfxVariant cfgVal[2];
+
+        m_Loader = MFXLoad();
+        if (nullptr == m_Loader) {
+            ALOGE("MFXLoad failed...is implementation in path?");
+            return OMX_ErrorUndefined;
+        }
+
+        /* Create configurations for implementation */
+        cfg[0] = MFXCreateConfig(m_Loader);
+        if (!cfg[0]) {
+            ALOGE("Failed to create a MFX configuration");
+            MFXUnload(m_Loader);
+            return OMX_ErrorUndefined;
+        }
+
+        cfgVal[0].Type = MFX_VARIANT_TYPE_U32;
+        cfgVal[0].Data.U32 = (m_Implementation == MFX_IMPL_SOFTWARE) ? MFX_IMPL_TYPE_SOFTWARE : MFX_IMPL_TYPE_HARDWARE;
+        sts = MFXSetConfigFilterProperty(cfg[0], (const mfxU8 *) "mfxImplDescription.Impl", cfgVal[0]);
+        if (MFX_ERR_NONE != sts) {
+            ALOGE("Failed to add an additional MFX configuration (%d)", sts);
+            MFXUnload(m_Loader);
+            return OMX_ErrorUndefined;
+        }
+
+        cfg[1] = MFXCreateConfig(m_Loader);
+        if (!cfg[1]) {
+            ALOGE("Failed to create a MFX configuration");
+            MFXUnload(m_Loader);
+            return OMX_ErrorUndefined;
+        }
+
+        cfgVal[1].Type = MFX_VARIANT_TYPE_U32;
+        cfgVal[1].Data.U32 = MFX_VERSION;
+        sts = MFXSetConfigFilterProperty(cfg[1], (const mfxU8 *) "mfxImplDescription.ApiVersion.Version", cfgVal[1]);
+        if (MFX_ERR_NONE != sts) {
+            ALOGE("Failed to add an additional MFX configuration (%d)", sts);
+            MFXUnload(m_Loader);
+            return OMX_ErrorUndefined;
+        }
+
+        while (1) {
+            /* Enumerate all implementations */
+            uint32_t idx = 0;
+            mfxImplDescription *idesc;
+            sts = MFXEnumImplementations(m_Loader, idx, MFX_IMPLCAPS_IMPLDESCSTRUCTURE, (mfxHDL *)&idesc);
+
+            if (MFX_ERR_NOT_FOUND == sts) {
+                /* Failed to find an available implementation */
+                break;
+            }
+            else if (MFX_ERR_NONE != sts) {
+                /*implementation found, but requested query format is not supported*/
+                idx++;
+                continue;
+            }
+            ALOGI("OneVPL %s. Idx = %d. ApiVersion: %d.%d. Implementation type: %s. AccelerationMode via: %d",
+                 __func__, idx, idesc->ApiVersion.Major, idesc->ApiVersion.Minor,
+                (idesc->Impl == MFX_IMPL_TYPE_SOFTWARE) ? "SW" : "HW",
+                idesc->AccelerationMode);
+
+            sts = MFXCreateSession(m_Loader, idx, &m_Session);
+
+            MFXDispReleaseImplDescription(m_Loader, idesc);
+
+            if (MFX_ERR_NONE == sts)
+                break;
+
+            idx++;
+        }
+
+        if (MFX_ERR_NONE != sts)
+        {
+            if (!m_Loader)
+                MFXUnload(m_Loader);
+
+            ALOGE("Failed to create a MFX session (%d)", sts);
+            return OMX_ErrorUndefined;
+        }
+#else
         sts = m_Session.Init(m_Implementation, &g_MfxVersion);
         MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "Session.Init sts %d, version %d.%d", sts, g_MfxVersion.Major, g_MfxVersion.Minor);
+        ALOGI("[MediaSDK] Session.Init sts %d, version %d.%d", sts, g_MfxVersion.Major, g_MfxVersion.Minor);
 
         if (MFX_ERR_NONE == sts)
         {
             sts = m_Session.QueryIMPL(&m_Implementation);
             MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "Session.QueryIMPL sts %d, impl 0x%04x", sts, m_Implementation);
         }
-
+#endif
         // encoder creation
         if (MFX_ERR_NONE == sts)
         {
@@ -174,7 +273,11 @@ OMX_ERRORTYPE MfxOmxVencComponent::Init(void)
     }
     if ((OMX_ErrorNone == error) && (MFX_IMPL_SOFTWARE != m_Implementation))
     {
+#ifdef USE_ONEVPL
+        sts = m_pDevice->InitMfxSession(m_Session);
+#else
         sts = m_pDevice->InitMfxSession(&m_Session);
+#endif
         if (MFX_ERR_NONE != sts) error = OMX_ErrorUndefined;
     }
     if (OMX_ErrorNone == error)
@@ -1683,7 +1786,11 @@ OMX_ERRORTYPE MfxOmxVencComponent::SetParameter(
                     {
                         MFX_OMX_AUTO_TRACE_I32(pParam->bStoreMetaData);
                         {
+#ifdef USE_ONEVPL
+                            m_MfxVideoParams.IOPattern &= !(MFX_IOPATTERN_IN_VIDEO_MEMORY | MFX_IOPATTERN_IN_SYSTEM_MEMORY);
+#else
                             m_MfxVideoParams.IOPattern &= !(MFX_IOPATTERN_IN_VIDEO_MEMORY | MFX_IOPATTERN_IN_SYSTEM_MEMORY | MFX_IOPATTERN_IN_OPAQUE_MEMORY);
+#endif
                             m_MfxVideoParams.IOPattern |= pParam->bStoreMetaData ? MFX_IOPATTERN_IN_VIDEO_MEMORY : MFX_IOPATTERN_IN_SYSTEM_MEMORY;
 
                             mfxU32 mode = pParam->bStoreMetaData ? MfxOmxInputSurfacesPool::MODE_LOAD_MDBUF
@@ -2609,7 +2716,11 @@ mfxStatus MfxOmxVencComponent::InitVPP(void)
         {
             MfxOmxVppWrappParam param;
 
+#ifdef USE_ONEVPL
+            param.session = m_Session;
+#else
             param.session = &m_Session;
+#endif
             param.frame_info = &(pSrf->Info);
             param.allocator = m_pDevice->GetFrameAllocator();
             param.conversion = ARGB_TO_NV12;
@@ -2937,7 +3048,11 @@ mfxStatus MfxOmxVencComponent::ProcessFrameEnc(bool bHandleEos)
                         if (pDevBusySyncPoint)
                         {
                             MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "SyncOperation+");
+#ifdef USE_ONEVPL
+                            mfx_sts = MFXVideoCORE_SyncOperation(m_Session, *pDevBusySyncPoint, MFX_OMX_INFINITE);
+#else
                             mfx_sts = m_Session.SyncOperation(*pDevBusySyncPoint, MFX_OMX_INFINITE);
+#endif
                             MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "SyncOperation- sts %d", mfx_sts);
                         }
                         else
@@ -3169,7 +3284,11 @@ void MfxOmxVencComponent::AsyncThread(void)
                 {
                     MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "SyncOperation+");
                     ATRACE_NAME("Wait Encode task completion");
+#ifdef USE_ONEVPL
+                    mfx_sts = MFXVideoCORE_SyncOperation(m_Session, *pSyncPoint, MFX_OMX_INFINITE);
+#else
                     mfx_sts = m_Session.SyncOperation(*pSyncPoint, MFX_OMX_INFINITE);
+#endif
                     MFX_OMX_LOG_INFO_IF(g_OmxLogLevel, "SyncOperation- sts %d", mfx_sts);
                     // sending event that some resources may be free
                     m_pDevBusyEvent->Signal();
diff --git a/omx_components/src/mfx_omx_vpp_wrapp.cpp b/omx_components/src/mfx_omx_vpp_wrapp.cpp
index 60c618f..4ebe9e1 100644
--- a/omx_components/src/mfx_omx_vpp_wrapp.cpp
+++ b/omx_components/src/mfx_omx_vpp_wrapp.cpp
@@ -33,7 +33,11 @@
 
 MfxOmxVppWrapp::MfxOmxVppWrapp(void):
     m_pVPP(NULL),
+#ifdef USE_ONEVPL
+    m_Session(NULL),
+#else
     m_session(NULL),
+#endif
     m_numVppSurfaces(0),
     m_EncodeCtrls{},
     m_dbg_vppout(NULL)
@@ -65,9 +69,13 @@ mfxStatus MfxOmxVppWrapp::Init(MfxOmxVppWrappParam *param)
     if (MFX_ERR_NONE == sts)
     {
         m_allocator = *param->allocator;
+#ifdef USE_ONEVPL
+        m_Session = param->session;
+        MFX_OMX_NEW(m_pVPP, MFXVideoVPP(m_Session));
+#else
         m_session = param->session;
-
         MFX_OMX_NEW(m_pVPP, MFXVideoVPP(*m_session));
+#endif
         if(!m_pVPP) sts = MFX_ERR_UNKNOWN;
 
         if (MFX_ERR_NONE == sts) sts = FillVppParams(param->frame_info, param->conversion);
@@ -131,7 +139,11 @@ mfxStatus MfxOmxVppWrapp::Close(void)
     MFX_OMX_ZERO_MEMORY(m_responses);
     MFX_OMX_ZERO_MEMORY(m_vppSrf);
     m_numVppSurfaces = 0;
+#ifdef USE_ONEVPL
+    m_Session = NULL;
+#else
     m_session = NULL;
+#endif
 
     if (m_dbg_vppout) fclose(m_dbg_vppout);
 
@@ -260,7 +272,13 @@ mfxStatus MfxOmxVppWrapp::ProcessFrameVpp(mfxFrameSurface1 *in_srf, mfxFrameSurf
     if (outSurface)
     {
         sts = m_pVPP->RunFrameVPPAsync(in_srf, outSurface, NULL, &syncp);
-        if (MFX_ERR_NONE == sts) sts = m_session->SyncOperation(syncp, MFX_OMX_INFINITE);
+        if (MFX_ERR_NONE == sts) {
+#ifdef USE_ONEVPL
+            sts = MFXVideoCORE_SyncOperation(m_Session, syncp, MFX_OMX_INFINITE);
+#else
+            sts = m_session->SyncOperation(syncp, MFX_OMX_INFINITE);
+#endif
+        }
     }
     else sts = MFX_ERR_MORE_SURFACE;
 
diff --git a/omx_utils/include/mfx_omx_defs.h b/omx_utils/include/mfx_omx_defs.h
index 31f967b..da0a56f 100755
--- a/omx_utils/include/mfx_omx_defs.h
+++ b/omx_utils/include/mfx_omx_defs.h
@@ -77,9 +77,17 @@
 #include <mfxvideo.h>
 #include <mfxvideo++.h>
 #include <mfxvp8.h>
+
+#ifndef USE_ONEVPL
 #include <mfxvp9.h>
+#endif
+
 #include <mfx_android_config.h>
 
+#if (MFX_VERSION >= 2000)
+    #include "mfxdispatcher.h"
+#endif
+
 /*------------------------------------------------------------------------------*/
 
 #ifdef __cplusplus
diff --git a/omx_utils/include/mfx_omx_dev.h b/omx_utils/include/mfx_omx_dev.h
index 5a8e4d9..4dd75db 100644
--- a/omx_utils/include/mfx_omx_dev.h
+++ b/omx_utils/include/mfx_omx_dev.h
@@ -34,7 +34,11 @@ public:
     virtual mfxStatus DevInit(void) = 0;
     virtual mfxStatus DevClose(void) = 0;
 
+#ifdef USE_ONEVPL
+    virtual mfxStatus InitMfxSession(mfxSession session) = 0;
+#else
     virtual mfxStatus InitMfxSession(MFXVideoSession* session) = 0;
+#endif
     virtual mfxFrameAllocator* GetFrameAllocator(void) = 0;
     virtual MfxOmxGrallocAllocator* GetGrallocAllocator(void) = 0;
 
diff --git a/omx_utils/include/mfx_omx_dev_android.h b/omx_utils/include/mfx_omx_dev_android.h
index 5918608..6b43e0f 100644
--- a/omx_utils/include/mfx_omx_dev_android.h
+++ b/omx_utils/include/mfx_omx_dev_android.h
@@ -44,7 +44,11 @@ public:
     virtual mfxStatus DevInit(void);
     virtual mfxStatus DevClose(void);
 
+#ifdef USE_ONEVPL
+    virtual mfxStatus InitMfxSession(mfxSession session);
+#else
     virtual mfxStatus InitMfxSession(MFXVideoSession* session);
+#endif
     virtual mfxFrameAllocator* GetFrameAllocator(void)
     {
         return m_pFrameAllocator;
diff --git a/omx_utils/src/mfx_omx_debug.cpp b/omx_utils/src/mfx_omx_debug.cpp
index 40900a3..0a2a85c 100644
--- a/omx_utils/src/mfx_omx_debug.cpp
+++ b/omx_utils/src/mfx_omx_debug.cpp
@@ -354,8 +354,10 @@ static CodeStringTable g_StatusNames[] =
     { MFX_ERR_UNDEFINED_BEHAVIOR,       "MFX_ERR_UNDEFINED_BEHAVIOR"},
     { MFX_ERR_DEVICE_FAILED,            "MFX_ERR_DEVICE_FAILED"},
     { MFX_ERR_MORE_BITSTREAM,           "MFX_ERR_MORE_BITSTREAM"},
+#ifndef USE_ONEVPL
     { MFX_ERR_INCOMPATIBLE_AUDIO_PARAM, "MFX_ERR_INCOMPATIBLE_AUDIO_PARAM"},
     { MFX_ERR_INVALID_AUDIO_PARAM,      "MFX_ERR_INVALID_AUDIO_PARAM"},
+#endif
     { MFX_ERR_GPU_HANG,                 "MFX_ERR_GPU_HANG"},
     { MFX_ERR_REALLOC_SURFACE,          "MFX_ERR_REALLOC_SURFACE"},
     { MFX_WRN_IN_EXECUTION,             "MFX_WRN_IN_EXECUTION"},
@@ -366,7 +368,9 @@ static CodeStringTable g_StatusNames[] =
     { MFX_WRN_VALUE_NOT_CHANGED,        "MFX_WRN_VALUE_NOT_CHANGED"},
     { MFX_WRN_OUT_OF_RANGE,             "MFX_WRN_OUT_OF_RANGE"},
     { MFX_WRN_FILTER_SKIPPED,           "MFX_WRN_FILTER_SKIPPED"},
+#ifndef USE_ONEVPL
     { MFX_WRN_INCOMPATIBLE_AUDIO_PARAM, "MFX_WRN_INCOMPATIBLE_AUDIO_PARAM"},
+#endif
     { MFX_TASK_WORKING,                 "MFX_TASK_WORKING"},
     { MFX_TASK_BUSY,                    "MFX_TASK_BUSY"}
 };
diff --git a/omx_utils/src/mfx_omx_dev_android.cpp b/omx_utils/src/mfx_omx_dev_android.cpp
index 1ec2590..8d8a9c3 100644
--- a/omx_utils/src/mfx_omx_dev_android.cpp
+++ b/omx_utils/src/mfx_omx_dev_android.cpp
@@ -285,6 +285,35 @@ mfxStatus MfxOmxDevAndroid::DevClose(void)
 
 /*------------------------------------------------------------------------------*/
 
+#ifdef USE_ONEVPL
+mfxStatus MfxOmxDevAndroid::InitMfxSession(mfxSession session)
+{
+    (void)session;
+
+    MFX_OMX_AUTO_TRACE_FUNC();
+    mfxStatus mfx_res = MFX_ERR_NONE;
+
+    if (!session) mfx_res = MFX_ERR_NULL_PTR;
+    if (MFX_ERR_NONE == mfx_res)
+    { // Check if already initialized
+        VADisplay dpy = NULL;
+        mfx_res = MFXVideoCORE_GetHandle(session, static_cast<mfxHandleType>(MFX_HANDLE_VA_DISPLAY), (mfxHDL*)&dpy);
+        if (MFX_ERR_NOT_FOUND == mfx_res && !dpy) mfx_res = MFX_ERR_NONE;
+        if (MFX_ERR_NONE == mfx_res && dpy) mfx_res = MFX_WRN_VALUE_NOT_CHANGED;
+    }
+
+    if (MFX_ERR_NONE == mfx_res)
+    {
+        mfx_res =  MFXVideoCORE_SetHandle(session, static_cast<mfxHandleType>(MFX_HANDLE_VA_DISPLAY), (mfxHDL)m_vaDpy);
+    }
+    if (MFX_ERR_NONE == mfx_res)
+    {
+        mfx_res = MFXVideoCORE_SetFrameAllocator(session, m_pFrameAllocator);
+    }
+    MFX_OMX_AUTO_TRACE_I32(mfx_res);
+    return mfx_res;
+}
+#else
 mfxStatus MfxOmxDevAndroid::InitMfxSession(MFXVideoSession* session)
 {
     MFX_OMX_AUTO_TRACE_FUNC();
@@ -310,6 +339,7 @@ mfxStatus MfxOmxDevAndroid::InitMfxSession(MFXVideoSession* session)
     MFX_OMX_AUTO_TRACE_I32(mfx_res);
     return mfx_res;
 }
+#endif
 
 /*------------------------------------------------------------------------------*/
 
-- 
2.35.1

